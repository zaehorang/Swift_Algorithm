//
// 5904.swift
// Swift_Algorithm
//
// Created by zaehorang on 2026/2/18.
// https://acmicpc.net/problem/5904
//

import Foundation

func _5904() {
    // ============================================================
    // [내 풀이] (정답은 맞을 수 있지만, 최악 케이스에서 메모리 초과 위험)
    // ------------------------------------------------------------
    // 핵심 아이디어는 "S(k)의 길이"를 키워가며 n이 포함될 k를 찾는 것까지는 최적해와 동일.
    // 다만 마지막에 moo 패턴을 Bool 배열로 "실제로 만들어" n번째를 찍는 방식이라,
    // k가 커지면 배열 길이가 2배씩 증가 + 배열 합치기(+)로 복사까지 발생해 메모리가 터질 수 있음.
    //
    // 시간/메모리 관점:
    // - 길이 계산(cnt): O(log n)
    // - moo 배열 생성: 길이가 2배씩 커져 O(len[k]) (실제로 만들면 매우 커짐)
    // ============================================================
    var n = Int(readLine()!)!
    var cnt = [3]
    var moo: [Bool] = [true, false, false]
    var k = 0
    
    // 1) cnt[k] = S(k)의 전체 길이
    //    S(k) = S(k-1) + (가운데 길이 k+3) + S(k-1)
    //    => cnt[k] = 2*cnt[k-1] + (k+3)
    //    n이 들어갈 만큼의 k를 찾는다.
    while true {
        let count = cnt[k]
        guard count < n else { break }
        
        k += 1
        cnt.append(2 * count + k + 3)
    }
    
    // 2) (개념적으로) S(k) = [왼쪽 S(k-1)] [가운데] [오른쪽 S(k-1)]
    //    n이 오른쪽에 있으면 n에서 (왼쪽 길이 + 가운데 길이)만큼 빼서
    //    오른쪽 블록 안의 "상대 위치"로 바꾸고 k를 줄여 내려간다.
    while true {
        guard k - 1 >= 0 else { break }
        
        if n >= cnt[k-1] + k + 3 {
            n -= (cnt[k-1] + k + 3)
            k -= 1
        } else {
            break
        }
    }
    
    if k > 0 {
        for i in 1...k {
            let mid = [true] + Array(repeating: false, count: i + 2)
            
            // 3) 여기서 최적해와 갈림
            //    - 내 풀이: moo를 실제로 만든다 (Bool 배열)
            //    - 최적해: moo를 절대 만들지 않고, 길이(len)와 idx만으로 n번째 문자를 결정한다.
            //
            // ⚠️ 메모리/시간이 급증하는 이유
            // moo = moo + mid + moo
            //  - 새 배열을 만들고 기존 moo를 "두 번" 복사한다.
            //  - moo 길이도 매 단계 2배로 증가한다.
            // => k가 조금만 커져도 메모리 피크가 크게 튄다.
            moo = moo + mid + moo
            
        }
    }
    print(moo[n-1] ? "m" : "o")
}

// ============================================================
// [최적해] (문자열/배열을 만들지 않고 길이와 위치(idx)만으로 결정)
// ------------------------------------------------------------
// 아이디어:
// 1) len[k] = S(k)의 전체 길이를 구해서, len[k] >= n이 되는 k를 찾는다.
// 2) S(k)의 구조가 항상
//      [왼쪽 S(k-1)] [가운데("m" + "o"*(k+2))] [오른쪽 S(k-1)]
//    이므로, idx가 왼쪽/가운데/오른쪽 중 어디에 속하는지만 판단하며 내려간다.
// 3) 가운데에 걸리면 즉시 답:
//    - 가운데의 첫 글자만 'm'
//    - 나머지는 전부 'o'
//
// 시간/메모리:
// - k는 len이 2배씩 커져서 대략 O(log n) 수준(수십 단계)
// - 문자열/배열 생성이 없어서 메모리는 len 배열 정도만 사용
// ============================================================
func _5904_() {
    let n = Int(readLine()!)!
    
    // (내 풀이의 cnt 계산과 동일한 단계) n이 포함될 만큼 len을 키운다.
    var len: [Int] = [3]
    var k = 0
    while len[k] < n {
        k += 1
        len.append(len[k - 1] * 2 + (k + 3))
    }
    
    // idx(=n번째 위치)를 "왼쪽/오른쪽으로 내려가며" 계속 줄여나간다.
    // 문자열을 만들지 않아도, idx가 가운데 블록에 걸리는 순간 답이 확정된다.
    var idx = n
    var cur = k
    
    while cur > 0 {
        let left = len[cur - 1]
        let mid = cur + 3
        
        if idx <= left {
            cur -= 1
        } else if idx > left + mid {
            idx -= (left + mid)
            cur -= 1
        } else {
            print(idx - left == 1 ? "m" : "o")
            return
        }
    }
    
    print(idx == 1 ? "m" : "o")
}
